<!doctype html>
<html lang="en">
<head>
	<meta charset="UTF-8" />
	<title>My First Game Built with Phaser 3</title>
	<script src="//cdn.jsdelivr.net/npm/phaser@3.1.1/dist/phaser.js"></script>
	<style type="text/css">
	html {
		width: 100%;
		height: 100%;
	}
	body {
		width: 100%;
		height: 100%;
		min-width: 800px;
		min-height: 600px;
		margin: 0;
		display: flex;
		text-align: center;
		align-items: center;
		justify-content: center;
	}
	</style>
</head>
<body>
	<script type="text/javascript">
	var config = {
		type: Phaser.AUTO,
		width: 800,
		height: 600,
		physics: {
			default: 'arcade',
			arcade: {
				gravity: { y: 1000 },
				debug: false
			}
		},
		scene: {
			preload: preload,
			create: create,
			update: update
		}
	};

	//----------------------------------------------------------------

	var defaultControlling = [{
		'up': new Phaser.Input.Keyboard.Key(87),				// key: W
		'down': new Phaser.Input.Keyboard.Key(83),				// key: S
		'left': new Phaser.Input.Keyboard.Key(65),				// key: A
		'right': new Phaser.Input.Keyboard.Key(68),				// key: D
		'jump': new Phaser.Input.Keyboard.Key(32),				// key: Space
		'shoot': new Phaser.Input.Keyboard.Key(76),				// key: L
		'aim': {
			'left': new Phaser.Input.Keyboard.Key(75),			// key: K
			'right': new Phaser.Input.Keyboard.Key(186),		// key: ;
			'top': new Phaser.Input.Keyboard.Key(79),			// key: O
			'bottom': new Phaser.Input.Keyboard.Key(190),		// key: .
			'lefttop': new Phaser.Input.Keyboard.Key(73),		// key: I
			'righttop': new Phaser.Input.Keyboard.Key(80),		// key: P
			'leftbottom': new Phaser.Input.Keyboard.Key(188),	// key: ,
			'rightbottom': new Phaser.Input.Keyboard.Key(191)	// key: /
		}
	}, {
		'up': new Phaser.Input.Keyboard.Key(104),				// key: num8
		'down': new Phaser.Input.Keyboard.Key(101),				// key: num5
		'left': new Phaser.Input.Keyboard.Key(100),				// key: num4
		'right': new Phaser.Input.Keyboard.Key(102),			// key: num6
		'jump': new Phaser.Input.Keyboard.Key(96),				// key: num0
		'shoot': new Phaser.Input.Keyboard.Key(72),				// key: H
		'aim': {
			'left': new Phaser.Input.Keyboard.Key(71),			// key: G
			'right': new Phaser.Input.Keyboard.Key(74),			// key: J
			'top': new Phaser.Input.Keyboard.Key(89),			// key: Y
			'bottom': new Phaser.Input.Keyboard.Key(78),		// key: N
			'lefttop': new Phaser.Input.Keyboard.Key(84),		// key: T
			'righttop': new Phaser.Input.Keyboard.Key(85),		// key: U
			'leftbottom': new Phaser.Input.Keyboard.Key(66),	// key: B
			'rightbottom': new Phaser.Input.Keyboard.Key(77)	// key: M
		}
	}];
	const defaultFps = 60;
	const defaultWalkVelocity = [300, 300];
	const defaultJumpVelocity = [-400, -400];
	const defaultStatePositionX = [80, 720];
	const defaultHealth = [5, 5];
	const defaultArrowsAmount = [3, 3];
	const defaultMaxArrowsAmount = [3, 3];
	const defaultArrowIconDirection = [1, -1];
	const defaultAimingDirection = [0, Math.PI];				// right, left
	const defaultArrowSpeed = 1000;
	const defaultArrowOnBodyCollectingTimeCost = [1.3, 1.3];				// measure in sec.
	const defaultArrowOnBodyCollectingCircleRadius = [10, 10];

	//----------------------------------------------------------------

	var testGetHit = false;

	var platforms;
	var player = [];
	var arrows;
	var stuckedArrows;
	var arrowSpeed = defaultArrowSpeed;
	var playerArrowCollider;
	var keys = {};
	var cursors;
	var mouseKeyIsDown = false;
	var mousePosition = {'x': null, 'y': null};

	var game = new Phaser.Game(config);

	function preload () {
		this.load.image('ground', 'src/game/img/ground.png');
		this.load.image('heart', 'src/game/img/heart.png');
		this.load.image('arrow-icon', 'src/game/img/arrow-icon.png');
		this.load.image('arrow', 'src/game/img/arrow.png');
		this.load.image('bow-n-arrow', 'src/game/img/bow-n-arrow.png');
		this.load.image('opened-bow', 'src/game/img/opened-bow.png');
		this.load.spritesheet('player-white', 'src/game/img/player-white.png', {frameWidth: 29, frameHeight: 60});
	}

	function create () {
		console.log(this);
		platforms = this.physics.add.staticGroup();

		platforms.create(400, 575, 'ground');
		platforms.setDepth(1);

		// Setup Players
		player[0] = this.physics.add.sprite(50, 500, 'player-white');
		player[1] = this.physics.add.sprite(750, 500, 'player-white').setTint(0xa0a0ff);

		for (let thePlayer of player) {
			thePlayer.setCollideWorldBounds(true);
			thePlayer.setBounce(0);
			thePlayer.setDepth(1);
		}

		// Setup Bow and Arrows
		for (let thePlayer of player) {
			thePlayer.bow = this.add.sprite(thePlayer.x, thePlayer.y, 'bow-n-arrow');
			thePlayer.bow.setDepth(1);
		}
		arrows = this.physics.add.group();
		stuckedArrows = this.physics.add.staticGroup();

		// Setup Physics Colliding & Overlapping
		for (let thePlayer of player) {
			this.physics.add.collider(thePlayer, platforms);
			this.physics.add.collider(arrows, platforms, arrowStuck, null, this);
			playerArrowCollider = this.physics.add.overlap(thePlayer, arrows, getHit, null, this);
		}
		for (let i = 0; i < player.length - 1; i++) {
			for (let j = i + 1; j < player.length; j++) {
				this.physics.add.collider(player[i], player[j])
			}
		}
		this.physics.add.collider(arrows, platforms);

		// Setup Players' Properties
		for (let i = 0; i < player.length; i++) {
			player[i].controlling = defaultControlling[i];
			player[i].walkVelocity = defaultWalkVelocity[i];
			player[i].jumpVelocity = defaultJumpVelocity[i];
			player[i].statePositionX = defaultStatePositionX[i];
			player[i].health = defaultHealth[i];
			player[i].arrowsAmount = defaultArrowsAmount[i];
			player[i].maxArrowsAmount = defaultMaxArrowsAmount[i];
			player[i].arrowIconDirection = defaultArrowIconDirection[i];
			player[i].aimingDirection = defaultAimingDirection[i];
			player[i].arrowOnBodyCollecting = {
				'timeCost': defaultArrowOnBodyCollectingTimeCost[i],
				'time': 0,
				'circle': this.add.graphics(player[i].x, player[i].y),
				'circleRadius': defaultArrowOnBodyCollectingCircleRadius[i]
			}
		}

		// Setup Player State Display
		for (let thePlayer of player) {
			thePlayer.stateDisplay = {
				'arrowIcons': this.add.group(),
				'heartIcon': this.add.image(thePlayer.statePositionX, 50, 'heart'),
				'healthText': this.add.text(thePlayer.statePositionX - 10, 50 - 14, '', {fontSize: '33px', fill: '#ffffff'})
			}
			for (var i = 0; i < thePlayer.maxArrowsAmount; i++) {
				thePlayer.stateDisplay.arrowIcons.create(thePlayer.statePositionX, i * 50 + 120, 'arrow-icon').scaleX *= thePlayer.arrowIconDirection;
			}
			updateHealthDisplay(thePlayer);
			updateArrowIcons(thePlayer);
		}

		// Setup Amination
		this.anims.create({
			key: 'front',
			frames: [ { key: 'player-white', frame: 0 } ],
			frameRate: 20
		});
		this.anims.create({
			key: 'side',
			frames: [ { key: 'player-white', frame: 2 } ],
			frameRate: 20
		});
		this.anims.create({
			key: 'crouch',
			frames: [ { key: 'player-white', frame: 1 } ],
			frameRate: 20
		});
		this.anims.create({
			key: 'walk',
			frames: this.anims.generateFrameNumbers('player-white', { start: 2, end: 3 }),
			frameRate: 10,
			repeat: -1
		});

		// Setup Input Event
		window.onkeydown = function (e) {
			keyDownTrigger(e.keyCode);
			keys[e.keyCode] = true;
		};
		window.onkeyup = function (e) {
			keyUpTrigger(e.keyCode);
			keys[e.keyCode] = undefined;
		};
		window.onmousedown = function (e) {
			if (e.button == 0) mouseKeyIsDown = true;
		}
		window.onmouseup = function (e) {
			if (e.button == 0) mouseKeyIsDown = false;
		}
		window.onmousemove = function (e) {
			let canvasRect = game.canvas.getBoundingClientRect();
			mousePosition.x = e.clientX - canvasRect.left;
			mousePosition.y = e.clientY - canvasRect.top;
		};
	}

	function update () {
		// Players' Movement
		// Players' Jump at func 'keyTrigger'
		for (let thePlayer of player) {
			if (thePlayer.health < 1) continue;
			if (isKeyDown(thePlayer.controlling.down.keyCode) && thePlayer.body.touching.down) {
				thePlayer.setVelocityX(0);
				thePlayer.anims.play('crouch', true);
			}
			else if (isKeyDown(thePlayer.controlling.left.keyCode) && isKeyDown(thePlayer.controlling.right.keyCode)) {
				thePlayer.setVelocityX(0);
				thePlayer.anims.play('front', true);
			}
			else if (isKeyDown(thePlayer.controlling.left.keyCode)) {
				thePlayer.setVelocityX(-1 * thePlayer.walkVelocity);
				thePlayer.scaleX = Math.abs(thePlayer.scaleX);
				if (thePlayer.body.touching.down) {
					thePlayer.anims.play('walk', true);
				} else {
					thePlayer.anims.play('side', true);
				}
			}
			else if (isKeyDown(thePlayer.controlling.right.keyCode)) {
				thePlayer.setVelocityX(thePlayer.walkVelocity);
				thePlayer.scaleX = -1 * Math.abs(thePlayer.scaleX);
				if (thePlayer.body.touching.down) {
					thePlayer.anims.play('walk', true);
				} else {
					thePlayer.anims.play('side', true);
				}
			}
			else {
				thePlayer.setVelocityX(0);
				thePlayer.anims.play('front', true);
			}
			if (isKeyDown(thePlayer.controlling.up.keyCode) && thePlayer.body.touching.down && thePlayer.arrowsAmount < thePlayer.maxArrowsAmount) {
				let arrowsOnBodyCount = 0;
				stuckedArrows.children.iterate(function (child) {
					if (child.stuckOn == thePlayer) {
						arrowsOnBodyCount += 1;
					}
				});
				if (arrowsOnBodyCount > 0) {
					thePlayer.setVelocity(0);
					thePlayer.anims.play('crouch', true);
					collectArrowOnBody(thePlayer);
				}
			}

			// Bows Direction
			for (let thePlayer of player) {
				let theX = thePlayer.x + ( thePlayer.body.velocity.x / defaultFps );
				let theY = thePlayer.y + ( thePlayer.body.velocity.y / defaultFps );
				thePlayer.bow.setPosition(theX, theY);
				thePlayer.bow.rotation = thePlayer.aimingDirection;
				if (thePlayer.arrowOnBodyCollecting.time > 0) {
					thePlayer.bow.setVisible(false);
					thePlayer.arrowOnBodyCollecting.circle.setVisible(true);
					thePlayer.arrowOnBodyCollecting.circle.setDepth(2);
				} else {
					thePlayer.bow.setVisible(true);
					// thePlayer.arrowOnBodyCollecting.circle.setVisible(false);
				}
			}
		}

		// Arrows Direction and LooseTime Count
		arrows.children.iterate(function (child) {
			child.rotation = Math.atan(child.body.velocity.y / child.body.velocity.x);
			if (child.body.velocity.x < 0) child.rotation += Math.PI;
			child.loosedTime += 1;
		});

		// Stucked Arrows
		stuckedArrows.children.iterate(function (child) {
			let velocityCompensatoryX = 0, velocityCompensatoryY = 0;
			if (child.stuckedType == 1) {
				velocityCompensatoryX = child.stuckOn.body.velocity.x / defaultFps;
				velocityCompensatoryY = child.stuckOn.body.velocity.y / defaultFps;
			}
			child.x = child.stuckOn.x + child.stuckPosition.x + velocityCompensatoryX;
			child.y = child.stuckOn.y + child.stuckPosition.y + velocityCompensatoryY;
		});

		 // if (testGetHit) { console.log('update getHit: true'); testGetHit = false }
		 // else { console.log('update getHit: false'); }
	}

	// ===== Tools Functions =====
	function isKeyDown (keyCode) {
		if (keys[keyCode]) return true ; else return false;
	}

	function keyDownTrigger (keyCode) {
		for (let thePlayer of player) {
			// Player Jump
			if (keyCode == thePlayer.controlling.jump.keyCode && thePlayer.body.touching.down && !isKeyDown(keyCode)) {	// Player Jump Detecting
				thePlayer.setVelocityY(thePlayer.jumpVelocity);
			}
			// Player shoot
			if (keyCode == thePlayer.controlling.shoot.keyCode && thePlayer.arrowsAmount > 0) {
				shootArrow(thePlayer);
			}
			if (keyCode == thePlayer.controlling.aim.right.keyCode) thePlayer.aimingDirection = 0;
			if (keyCode == thePlayer.controlling.aim.righttop.keyCode) thePlayer.aimingDirection = -1 * Math.PI / 4;
			if (keyCode == thePlayer.controlling.aim.top.keyCode) thePlayer.aimingDirection = -1 * Math.PI / 2;
			if (keyCode == thePlayer.controlling.aim.lefttop.keyCode) thePlayer.aimingDirection = -3 * Math.PI / 4;
			if (keyCode == thePlayer.controlling.aim.left.keyCode) thePlayer.aimingDirection = Math.PI;
			if (keyCode == thePlayer.controlling.aim.rightbottom.keyCode) thePlayer.aimingDirection = Math.PI / 4;
			if (keyCode == thePlayer.controlling.aim.bottom.keyCode) thePlayer.aimingDirection = Math.PI / 2;
			if (keyCode == thePlayer.controlling.aim.leftbottom.keyCode) thePlayer.aimingDirection = 3 * Math.PI / 4;
		}
	}
	function keyUpTrigger (keyCode) {
		for (let thePlayer of player) {
			if (keyCode == thePlayer.controlling.up.keyCode) {
				thePlayer.arrowOnBodyCollecting.time = 0;
			}
		}
	}

	// ===== Game Functions =====
	function shootArrow (thePlayer) {
		thePlayer.arrowsAmount += -1;
		updateArrowIcons(thePlayer);
		let theX = thePlayer.x + ( thePlayer.body.velocity.x / defaultFps );
		let theY = thePlayer.y + ( thePlayer.body.velocity.y / defaultFps );
		let theArrow = arrows.create(theX, theY, 'arrow');
		theArrow.setCollideWorldBounds(true);
		theArrow.setBounce(0.3);
		theArrow.from = thePlayer;
		theArrow.rotation = thePlayer.aimingDirection;
		let velocityX = Math.round(arrowSpeed * Math.cos(thePlayer.aimingDirection), 3);
		let velocityY = Math.round(arrowSpeed * Math.sin(thePlayer.aimingDirection), 3);
		theArrow.setVelocity(velocityX, velocityY);
		theArrow.loosedTime = 0;	// measure in frame
	}
	function getHit (thePlayer, theArrow) {
		// console.log('getHit');
		// testGetHit = true;
		if (theArrow.from == thePlayer) theArrow.loosedTime += -1;

		if (theArrow.loosedTime > 0 || theArrow.from != thePlayer) {
			thePlayer.health += -1;
			updateHealthDisplay(thePlayer);
			arrows.remove(theArrow);
			theArrow.body.allowGravity = false;
			theArrow.setVelocity(0, 0);
			theArrow.stuckedType = 1;		// 0 for static object, 1 for non-static object
			theArrow.stuckOn = thePlayer;
			theArrow.stuckPosition = { x: theArrow.x - thePlayer.x, y: theArrow.y - thePlayer.y };
			stuckedArrows.add(theArrow);
		}
	}
	function arrowStuck (theArrow, thePlatform) {
		arrows.remove(theArrow);
		theArrow.body.allowGravity = false;
		theArrow.setVelocity(0, 0);
		theArrow.stuckedType = 0;		// 0 for static object, 1 for non-static object
		theArrow.stuckOn = thePlatform;
		theArrow.stuckPosition = {x: theArrow.x - thePlatform.x, y: theArrow.y - thePlatform.y};
		stuckedArrows.add(theArrow);
	}
	function collectArrowOnBody (thePlayer) {
		thePlayer.arrowOnBodyCollecting.time += 1;
		let theRadius = thePlayer.arrowOnBodyCollecting.circleRadius;
		let startAngle = -1 * Math.PI / 2;
		let progressingState = thePlayer.arrowOnBodyCollecting.time / thePlayer.arrowOnBodyCollecting.timeCost;
		let endAngle = 2 * Math.PI * progressingState + startAngle;
		thePlayer.arrowOnBodyCollecting.circle.lineStyle(3, 0x999999, 0.7);
		thePlayer.arrowOnBodyCollecting.circle.arc(0, 0, theRadius, startAngle, endAngle, false);
		if (thePlayer.arrowOnBodyCollecting.time > thePlayer.arrowOnBodyCollecting.timeCost * defaultFps) {
			let done = false;
			thePlayer.arrowOnBodyCollecting.time = 0;
			for (let theArrow of stuckedArrows.getChildren()) {
				if (theArrow.stuckOn == thePlayer && !done) {
					theArrow.setVisible(false);
					stuckedArrows.remove(theArrow);
					thePlayer.arrowsAmount += 1;
					updateArrowIcons(thePlayer);
					done = true;
				}
			}
		}
	}

	function updateHealthDisplay (thePlayer) {
		thePlayer.stateDisplay.healthText.setText('' + thePlayer.health);
	}
	function updateArrowIcons (thePlayer) {
		thePlayer.stateDisplay.arrowIcons.children.iterate(function (child) {
			child.setVisible(false);
		});
		for (var i = 0; i < thePlayer.arrowsAmount; i++) {
			thePlayer.stateDisplay.arrowIcons.getChildren()[i].setVisible(true);
		}
	}

	</script>
</body>
</html>
